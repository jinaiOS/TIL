# 신경망을 위한 데이터 표현
- 텐서: 데이터를 위한 컨테이너, 일반적으로 기본 데이터 구조로 사용

## 스칼라(0D 텐서)

- 하나의 숫자만 담고 있는 텐서
- 넘파이에서는 float32나 float64 타입의 숫자
- ndim 속성을 사용하면 넘파이 배열의 축 개수를 확인할 수 있음
- 스칼라 텐서의 축 개수는 0, 텐서의 축 개수를 랭크라고 부름

```python
>>> import numpy as np
>>> x = np.array(12) // 12라는 값을 사용하여 0차원 배열 x를 생성
>>> x // x를 출력하면 array(12)로 표시
array(12)
>>> x.ndim // ndim 속성을 통해 x의 차원을 확인
0
```

## 벡터(1D 텐서)

- 숫자의 배열
- 딱 하나의 축을 가짐

```python
/// 5개의 원소를 가지므로 5차원 벡터
>>> x = np.array([12, 3, 6, 14, 7])
>>> x
array([12, 3, 6, 14, 7])
>>> x. ndim
1
```

## 행렬(2D 텐서)

- 벡터의 배열
- 2개의 축
- 첫 번째 축에 놓여 있는 원소를 행, 두 번째 축에 놓여 있는 원소를 열

```python
/// x의 첫 번째 행은 [5, 78, 2, 34, 0], 첫 번째 열은 [5, 6, 7]
>>> x = np.array([[5, 78, 2, 34, 0].
                  [6, 79, 3, 35, 1],
                  [7, 80, 4, 36, 2]])
```

## 3D 텐서와 고차원 텐서

- 3D 텐서: 직육면체 형태 해석
- 5D 텐서: 동영상 데이터 다룰 경우

```python
/// 3D 텐서
>>> x = np.array([[[5, 78, 2, 34, 0].
                   [6, 79, 3, 35, 1],
                   [7, 80, 4, 36, 2]],
                  [[5, 78, 2, 34, 0].
                   [6, 79, 3, 35, 1],
                   [7, 80, 4, 36, 2]],
                  [[5, 78, 2, 34, 0].
                   [6, 79, 3, 35, 1],
                   [7, 80, 4, 36, 2]]])
>>> x.ndim
3
```

## 핵심 속성

- 축의 개수(랭크)
- 크기: 각 축을 따라 얼마나 많은 차원이 있는지 나타낸 튜플
- 데이터 타입(넘파이에서는 dtype에 저장): 텐서에 포함된 데이터의 타입, 사전에 할당되어 연속된 메모리에 저장되어야 하므로 넘파이 배열은 가변 길이의 문자열을 지원하지 않음

## 넘파이로 텐서 조작하기

### 슬라이싱

- 배열에 있는 특정 원소를 선택하는 것

```python
/// 11번째에서 101번째까지(101번째는 포함하지 않고) 데이터 선택
>>> my_slice = train_images[10:100]
>>> print(my_slice.shape)
(90, 28, 28) // 90개의 이미지를 포함, 28x28 픽셀 크기
```

```python
/// 위와 동일하지만 조금 더 자세한 표기법, 각 배열의 축을 따라 슬라이싱의 시작 인덱스와 마지막 인덱스 지정
/// :(콜론)은 전체 인덱스 실행
>>> my_slice = train_images[10:100, :, :]
>>> my_slice.shape
(90, 28, 28)
>>> my_slice = train_images[10:100, 0:28, 0:28]
>>> my_slice.shape
(90, 28, 28)
```

```python
/// 각 배열의 축을 따라 어떤 인덱스 사이도 선택 가능
/// 이미지 오른쪽 아래 14x14 픽셀 선택
my_slice = train_images[:, 14:, 14:]
```

```python
/// 음수 인덱스 사용 가능
/// 정중앙에 위치한 14x14 픽셀 조각을 이미지에서 잘라 냄
my_slice = train_images[:, 7:-7, 7:-7]
```

## 배치 데이터

- 샘플 축(= 샘플 차원): 모든 데이터 텐서의 첫 번째 축(0번째 축)
- 배치 축(= 배치 차원): 배치 데이터를 다룰 때 첫 번째 축(0번째 축)
- 한 번에 전체 데이터셋을 처리하지 않음, 데이터를 작은 배치로 나눔

```python
/// MNIST 숫자 데이터에서 크기가 128인 배치 하나
batch = train_images[:128]
```

```python
/// 그 다음 배치
batch = train_images[128:256]
```

```python
/// n 번째 배치
batch = train_images[128 * n:128 * (n + 1)]
```

## 텐서의 실제 사례

### 벡터 데이터

1. 2D 텐서:
    - 벡터 데이터는 일반적으로 2D 텐서로 표현, 이 텐서는 행렬과 비슷하며, 두 개의 축을 가짐
    - 크기: `(samples, features)` 형태로, `samples`는 데이터 포인트 수, `features`는 각 데이터 포인트의 특성 수를 나타냄
2. 샘플 축 (첫 번째 축):
    - 첫 번째 축은 샘플 축으로, 각 샘플(데이터 포인트)을 나타냄
    - 예를 들어, 100개의 데이터 포인트가 있다면, 이 축의 크기는 100
3. 특성 축 (두 번째 축):
    - 두 번째 축은 특성 축으로, 각 샘플이 가지는 특성의 수를 나타냄
    - 예를 들어, 각 샘플이 5개의 특성을 가지면, 이 축의 크기는 5
4. example
    - 사람의 나이, 우편 번호, 소득으로 구성된 인구 통계 데이터. 각 사람은 3개의 값을 가진 벡터로 구성되고 10만 명이 포함된 전체 데이터셋은 (100000, 3) 크기의 텐서에 저장될 수 있음

### 시계열 데이터 또는 시퀀스 데이터

- 데이터에서 시간이 (또는 연속된 순서가) 중요할 때는 시간 축을 포함하여 3D 텐서에 저장
- 관례적으로 시간 축은 항상 두 번째 축(인덱스가 1인 축)
- example
    - 주식 가격 데이터셋: 1분마다 현재 주식 가격, 지난 1분 동안에 최고 가격과 최소 가격을 저장. 1분마다 데이터는 3D 벡터로 인코딩되고 하루 동안의 거래는 (390, 3) 크기의 2D 텐서로 인코딩됨(하루 거래 시간은 390분). 250일 치의 데이터는 (250, 390, 3) 크기의 3D 텐서로 저장 가능. 여기에서 1일 치 데이터가 하나의 샘플이 됨

### 이미지 데이터

- 전형적으로 높이, 너비, 컬러 채널의 3차원으로 이루어짐
- 흑백 이미지는 하나의 컬러 채널만을 가지고 있어 2D 텐서로 저장 가능하나 관례상 이미지 텐서는 3D 저장
- example
    - 흑백 이미지 128개 배치 (128, 256, 256, 1) 크기 텐서에 저장
    - 컬러 이미지 128개 배치 (128, 256, 256, 3) 크기 텐서에 저장
- 크기 지정 방법
    - (텐서플로) 채널 마지막 방식: (samples, height, width, color_depth)
    - (씨아노) 채널 우선 방식: (samples, color_depth, height, width)
    - 케라스 프레임워크는 두 형식 모두 지원

### 비디오 데이터

- 프레임의 연속, 각 프레임은 하나의 컬러 이미지
- 프레임: (height, width, color_depth) 3D 텐서로 저장
- 프레임 연속: (frames, height, width, color_depth) 4D 텐서로 저장
- 여러 비디오 배치: (samples, frames, height, width, color_depth) 5D 텐서로 저장
- example
    - 60초짜리 144x256 유튜브 비디오 클립을 초당 4프레임으로 샘플링하면 240 프레임이 됨 → 이 비디오 클립을 4개 가진 배치는 (4, 240, 144, 256, 3) 크기 텐서에 저장
    - 총 106, 168, 320개의 값
    - 이 턴세의 dtype을 float32로 했다면 각 값이 32비트로 저장될 것이므로 텐서의 저장 크기는 405MB
